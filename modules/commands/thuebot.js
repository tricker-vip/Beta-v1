const ADMIN_ID = "100020460654779";
const fs = require('fs');
const crypto = require('crypto');
const moment = require('moment-timezone');

const keysFilePath = __dirname + '/data/keys.json';
const dataFilePath = __dirname + '/data/thuebot.json';
const balancesFilePath = __dirname + '/data/balances.json';

let keysData = fs.existsSync(keysFilePath) ? require(keysFilePath) : [];
let data = fs.existsSync(dataFilePath) ? require(dataFilePath) : [];
let balances = fs.existsSync(balancesFilePath) ? require(balancesFilePath) : {};

const saveKeys = () => fs.writeFileSync(keysFilePath, JSON.stringify(keysData, null, 2));
const saveData = () => fs.writeFileSync(dataFilePath, JSON.stringify(data));
const saveBalances = () => fs.writeFileSync(balancesFilePath, JSON.stringify(balances));

const listKeys = (userId) => {
    // Li·ªát k√™ t·∫•t c·∫£ c√°c key kh√¥ng b·ªã k√≠ch ho·∫°t
    const inactiveKeys = keysData.filter(k => !k.activated);
    
    if (inactiveKeys.length === 0) {
        return "Tr·ªëng ‚ùé"; // Return message if no inactive keys are found
    }
    
    return inactiveKeys.map((key, index) => {
        const userName = global.data.userName.get(key.creatorId) || key.creatorId;
        return `${index + 1}. ${key.key}\nNg∆∞·ªùi s·ªü h·ªØu: ${userName}\nTh·ªùi gian h·∫øt h·∫°n: ${moment().add(key.days, 'days').format('DD/MM/YYYY')}`;
    }).join('\n________________\n');
};

const generateKey = (creatorId, days = 30, ownerId, isAdminKey = false) => {
    const key = `KeyBot_${crypto.randomBytes(2).toString('hex')}_¬©2024`;
    keysData.push({ key, activated: false, creatorId, days, ownerId, isAdminKey });
    saveKeys();
    return key;
};

const activateKey = (key, userId) => {
    const keyEntry = keysData.find(k => k.key === key && !k.activated);
    if (!keyEntry) return false;

    keyEntry.activated = true;
    keyEntry.time_start = moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY');
    keyEntry.time_end = moment().add(keyEntry.days, 'days').format('DD/MM/YYYY');
    saveKeys();
    return { time_end: keyEntry.time_end, days: keyEntry.days };
};

const extendRental = (userId, threadId, days = 30) => {
    const existingRental = data.find(entry => entry.id === userId && entry.t_id === threadId);
    let time_end;

    if (existingRental) {
        existingRental.time_end = moment(existingRental.time_end, 'DD/MM/YYYY').add(days, 'days').format('DD/MM/YYYY');
        time_end = existingRental.time_end;
    } else {
        const time_start = moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY');
        time_end = moment().add(days, 'days').format('DD/MM/YYYY');
        data.push({ t_id: threadId, id: userId, time_start, time_end });
    }

    saveData();
    return time_end;
};

const addMoney = (userId, amount) => {
    if (!balances[userId]) balances[userId] = 0;
    balances[userId] += amount;
    saveBalances();
};

const checkBalance = userId => {
    return balances[userId] || 0;
};

const purchaseKey = (userId, days) => {
    const keyCost = days; // 1$ m·ªói ng√†y
    const currentBalance = checkBalance(userId);
    if (currentBalance < keyCost) return { success: false, neededAmount: keyCost - currentBalance };
    balances[userId] -= keyCost;
    const newKey = generateKey(userId, days, userId, false); // truy·ªÅn false cho isAdminKey
    saveBalances();

    return { success: true, newKey };
};

module.exports.config = {
    name: 'rent',
    version: '1.3.7',
    hasPermssion: 0,
    credits: 'DC-Nam & DongDev source l·∫°i & g·∫•u th√™m key',
    description: 'thu√™ bot',
    commandCategory: 'Admin',
    usages: '[]',
    cooldowns: 5,
    usePrefix: false,
};

exports.run = function (o) {
    const send = (msg, callback) => o.api.sendMessage(msg, o.event.threadID, callback, o.event.messageID);
    const t_id = o.event.threadID;
    const userId = o.event.type === "message_reply" ? o.event.messageReply.senderID : Object.keys(o.event.mentions)[0] || o.event.senderID;
    const time_start = moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY');
    const time_end = moment().add(30, 'days').format('DD/MM/YYYY');

    const args = o.args;

    switch (args[0]) {
        case 'add': {
            if (o.event.senderID != ADMIN_ID) {
                return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
            }

            if (!o.args[1]) {
                return send(`‚ö†Ô∏è Th√™m ng∆∞·ªùi thu√™ bot v√†o d·ªØ li·ªáu:\n - thuebot add + ng√†y h·∫øt h·∫°n\n - thuebot add + id ng∆∞·ªùi thu√™ + ng√†y h·∫øt h·∫°n\n - thuebot add id nh√≥m + id ng∆∞·ªùi thu√™ + ng√†y h·∫øt h·∫°n\n‚ö†Ô∏è L∆∞u √Ω: ƒë·ªãnh d·∫°ng ng√†y l√† DD/MM/YYY`);
            }

            let userId = o.event.senderID;
            if (o.event.type === "message_reply") {
                userId = o.event.messageReply.senderID;
            } else if (Object.keys(o.event.mentions).length > 0) {
                userId = Object.keys(o.event.mentions)[0];
            }

            let t_id = o.event.threadID;
            let id = userId;
            let time_start = moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY');
            let time_end = o.args[1];

            if (o.args.length === 4 && !isNaN(o.args[1]) && !isNaN(o.args[2]) && o.args[3].match(/\d{1,2}\/\d{1,2}\/\d{4}/)) {
                t_id = o.args[1];
                id = o.args[2];
                time_end = o.args[3];
            } else if (o.args.length === 3 && !isNaN(o.args[1]) && o.args[2].match(/\d{1,2}\/\d{1,2}\/\d{4}/)) {
                id = o.args[1];
                time_end = o.args[2];
            }

            if (isNaN(id) || isNaN(t_id)) {
                return send(`‚ö†Ô∏è ID Kh√¥ng H·ª£p L·ªá!`);
            }

            if (!moment(time_end, 'DD/MM/YYYY', true).isValid()) {
                return send(`‚ö†Ô∏è Th·ªùi Gian Kh√¥ng H·ª£p L·ªá!`);
            }

            data.push({
                t_id,
                id,
                time_start,
                time_end,
            });

            saveData();
            send(`‚òëÔ∏è ƒê√£ th√™m ng∆∞·ªùi thu√™ bot v√†o danh s√°ch!`);
            break;
        }
        case 'list': {
            if (o.event.senderID != ADMIN_ID) {
                return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
            }
            const list = data.map(($, i) => {
                const userName = global.data.userName.get($.id) || $.id;
                const threadName = (global.data.threadInfo.get($.t_id) || {}).threadName || $.t_id;
                const status = new Date(moment($.time_end, 'DD/MM/YYYY').tz('Asia/Ho_Chi_Minh')).getTime() >= Date.now() ? '‚úÖ' : '‚ùé';
                return `${i + 1}. ${userName}\nT√¨nh tr·∫°ng: ${status}\nNh√≥m: ${threadName}`;
            }).join('\n__________________\n');

            send(`[ DANH S√ÅCH THU√ä BOT ]\n__________________\n${list}\n__________________\n‚©∫ Reply stt, del, out, giahan`, (err, res) => {
                res.name = exports.config.name;
                res.event = o.event;
                res.data = data;
                global.client.handleReply.push(res);
            });
            break;
        }
        case 'listkey': {
    if (o.event.senderID !== ADMIN_ID) {
        return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
    }

    // Get the list of inactive keys for the current user
    const inactiveKeysList = listKeys(o.event.senderID);
    
    if (inactiveKeysList === "Tr·ªëng ‚ùé") {
        return send(`[ Key ch∆∞a activated ]\n\nTr·ªëng ‚ùé`);
    }

    send(`[ Key ch∆∞a activated ]\n\n${inactiveKeysList}\n\n‚©∫ Reply rm + stt ƒë·ªÉ x√≥a`, (err, res) => {
        if (err) {
            console.error(`Error sending message: ${err}`);
            return send(`‚ö†Ô∏è ƒê√£ x·∫£y ra l·ªói khi g·ª≠i danh s√°ch key.`);
        }
        res.name = exports.config.name;
        res.event = o.event;
        res.data = keysData;
        global.client.handleReply.push(res);
    });
    break;
}
case 'newkey': {
    if (o.event.senderID !== ADMIN_ID) {
        return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
    }

    // Parse the number of days from the arguments
    const days = parseInt(args[1], 10);
    if (isNaN(days) || days <= 0) {
        return send(`‚ö†Ô∏è S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.`);
    }
const result = purchaseKey(userId, days);
    send(`üîë Key m·ªõi ƒë√£ ƒë∆∞·ª£c t·∫°o: ${result.newKey}\nüïí Th·ªùi gian hi·ªáu l·ª±c: ${days} ng√†y.`);
    break;
}
        case 'crekey': {
            if (o.event.senderID != ADMIN_ID) {
                return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
            }
            const days = args[1] ? parseInt(args[1], 10) : 30;
            if (isNaN(days) || days <= 0) return send(`‚ö†Ô∏è S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.`);
            send(`üîë Key m·ªõi: ${generateKey(userId, days, null, true)}\nüïí S·ªë ng√†y: ${days}`);
            break;
        }
        case 'bank': {
            if (o.event.senderID != ADMIN_ID) {
                return send(`‚ö†Ô∏è Ch·ªâ Admin ch√≠nh m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!`);
            }

            let targetUserId;
            if (args.length === 3) {
                targetUserId = args[1];
            } else if (o.event.type === "message_reply") {
                targetUserId = o.event.messageReply.senderID;
            } else if (Object.keys(o.event.mentions).length > 0) {
                targetUserId = Object.keys(o.event.mentions)[0];
            } else {
                return send(`‚ö†Ô∏è S·ª≠ d·ª•ng: ${global.config.PREFIX}rent bank <userId | @mention | reply> <amount>`);
            }

            const amount = parseFloat(args[args.length - 1]);
            if (isNaN(amount)) {
                return send(`‚ö†Ô∏è S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.`);
            }

            addMoney(targetUserId, amount);
            send(`‚òëÔ∏è ƒê√£ c·ªông ${amount}$ v√†o t√†i kho·∫£n c·ªßa ng∆∞·ªùi d√πng ${global.data.userName.get(targetUserId) || targetUserId}.`);
            break;
        }
        case 'money': {
            const balance = checkBalance(userId);
            send(`üí∞ S·ªë d∆∞: ${balance}$`);
            break;
        }
        case 'me': {
            const inactiveKeysList = listKeys(userId);
            send(`[ my key no activated ]\n\n${inactiveKeysList}`);
            break;
        }
        case 'buy': {
            const days = parseInt(args[1], 10);
            if (isNaN(days) || days <= 0) return send(`‚ö†Ô∏è S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.`);
            
            // G·ªçi h√†m mua key v·ªõi s·ªë ng√†y ƒë∆∞·ª£c ch·ªçn
            const result = purchaseKey(userId, days);
            
            if (!result.success) return send(`‚ö†Ô∏è B·∫°n c·∫ßn th√™m ${result.neededAmount}$ ƒë·ªÉ mua key n√†y!.`);
            
            send(`‚úÖ success: ${result.newKey}\nüïí S·ªë ng√†y: ${days}`);
            break;
        }
        default:
            send(`[ Danh s√°ch l·ªánh rent ]\n‚©∫ D√†nh cho Admin\n${global.config.PREFIX}rent add\n${global.config.PREFIX}rent list\n${global.config.PREFIX}rent listkey\n${global.config.PREFIX}rent newkey\n${global.config.PREFIX}rent crekey\n${global.config.PREFIX}rent bank\n‚©∫ D√†nh cho ng∆∞·ªùi d√πng\n${global.config.PREFIX}rent money ‚©∫ xem x·ªë d∆∞ t√†i kho·∫£n\n${global.config.PREFIX}rent me ‚©∫ xem key nh√≥m m√¨nh\n${global.config.PREFIX}rent buy ‚©∫ nh·∫≠p s·ªë ng√†y 1 ng√†y 1xu`);
    }
    saveData();
};

exports.handleReply = async function (o) {
    const send = (msg, callback) => o.api.sendMessage(msg, o.event.threadID, callback, o.event.messageID);
    if (o.event.senderID != o.handleReply.event.senderID) return;

    const args = o.event.body.split(' ');
    const action = args[0].toLowerCase();

    if (isFinite(action)) {
        const info = data[action - 1];
        if (!info) return send(`‚ùé STT kh√¥ng t·ªìn t·∫°i!`);

        const time_diff = new Date(moment(info.time_end, 'DD/MM/YYYY').tz('Asia/Ho_Chi_Minh')).getTime() - Date.now();
        const rentalStatus = time_diff <= 0 ? "ƒê√£ h·∫øt th·ªùi h·∫°n thu√™ üîê" : "";

        return send(`[ TH√îNG TIN NG∆Ø·ªúI THU√ä BOT ]\nüë§ Ng∆∞·ªùi thu√™: ${global.data.userName.get(info.id) || info.id}\nüåê Link Facebook: https://www.facebook.com/profile.php?id=${info.id}\nüë• Nh√≥m: ${(global.data.threadInfo.get(info.t_id) || {}).threadName || info.t_id}\nüî∞ TID: ${info.t_id}\nüìÜ Ng√†y Thu√™: ${info.time_start}\n‚è≥ Ng√†y h·∫øt H·∫°n: ${info.time_end} ${rentalStatus}`);
    } else {
        switch (action) {
            case 'del': {
                const sttList = args.slice(1).map(stt => parseInt(stt)).filter(stt => !isNaN(stt));
                if (sttList.length === 0) return send(`‚ùé Kh√¥ng c√≥ STT n√†o h·ª£p l·ªá!`);
                
                sttList.sort((a, b) => b - a).forEach(stt => data.splice(stt - 1, 1));
                send(`‚òëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng!`);
                saveData();
                break;
            }
            case 'giahan': {
                const stt = args[1];
                if (!data[stt - 1]) return send(`‚ùé STT kh√¥ng t·ªìn t·∫°i`);
                const time_end = moment().add(30, 'days').format('DD/MM/YYYY');
                data[stt - 1].time_end = time_end;
                send(`‚òëÔ∏è ƒê√£ gia h·∫°n nh√≥m th√†nh c√¥ng ƒë·∫øn ng√†y ${time_end}!`);
                saveData();
                break;
            }
            case 'out': {
                for (const i of args.slice(1)) {
                    await o.api.removeUserFromGroup(o.api.getCurrentUserID(), data[i - 1].t_id);
                }
                send(`‚ö†Ô∏è ƒê√£ out nh√≥m theo y√™u c·∫ßu`);
                break;
            }
            case 'rm': {
                const sttList = args.slice(1).map(stt => parseInt(stt)).filter(stt => !isNaN(stt));
                if (sttList.length === 0) return send(`‚ùé Kh√¥ng c√≥ STT n√†o h·ª£p l·ªá!`);
                
                sttList.sort((a, b) => b - a).forEach(stt => keysData.splice(stt - 1, 1));
                send(`‚òëÔ∏è ƒê√£ x√≥a key th√†nh c√¥ng!`);
                saveKeys();
                break;
            }
            default: {
                send(`‚ö†Ô∏è L·ªánh kh√¥ng h·ª£p l·ªá!`);
                break;
            }
        }
    }
};

module.exports.handleEvent = function (o) {
    const activationResult = activateKey(o.event.body, o.event.senderID);
    if (activationResult) {
        const { time_end, days } = activationResult;
        const time_start = moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY');
        const updatedTimeEnd = extendRental(o.event.senderID, o.event.threadID, days);
        saveData();
        
        // C·∫≠p nh·∫≠t t√™n nh√≥m
        const expectedNickname = `„Äé ${global.config.PREFIX} „Äè ‚™º ${(!global.config.BOTNAME) ? " ô·¥è·¥õ …¢·¥Ä·¥ú ( ô·¥á·¥õ·¥Ä)" : global.config.BOTNAME} | HSD ${time_end}`;
        o.api.changeNickname(expectedNickname, o.event.threadID, o.api.getCurrentUserID(), (error) => {
            if (error) {
                console.error(`Kh√¥ng th·ªÉ thay ƒë·ªïi bi·ªát danh bot: ${error}`);
            }
        });

        if (time_end !== updatedTimeEnd) {
            o.api.sendMessage(`‚òëÔ∏è Key h·ª£p l·ªá! Bot ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√™m ${days} ng√†y.\nüìÜ Ng√†y b·∫Øt ƒë·∫ßu: ${time_start}\n‚è≥ Ng√†y h·∫øt h·∫°n: ${updatedTimeEnd}`, o.event.threadID);
        } else {
            o.api.sendMessage(`‚òëÔ∏è Key h·ª£p l·ªá! Bot ƒë√£ ƒë∆∞·ª£c thu√™ trong ${days} ng√†y.\nüìÜ Ng√†y b·∫Øt ƒë·∫ßu: ${time_start}\n‚è≥ Ng√†y h·∫øt h·∫°n: ${time_end}`, o.event.threadID);
        }
    }
};